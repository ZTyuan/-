2.魔法能量场
背景
在我们的新款魔法主题⼿游"奇幻法师塔"中，玩家需要在不同位置建造能量塔来创造魔法能量场。游
戏地图是⼀个⻓条形的区域，玩家可以在不同位置建造不同⾼度的能量塔。
任务
作为游戏开发团队的⼀员，你需要设计⼀个算法来帮助玩家找出最佳的能量塔建造位置。两座能量塔
之间会形成⼀个梯形能量场，能量场的强度取决于两座塔的⾼度和它们之间的距离。
要求
1. 实现 MaxEnergyField ⽅法，该⽅法接收⼀个参数：
◦ heights :⼀个整数数组，表⽰在每个位置能建造的能量塔的最⼤⾼度
2. ⽅法应返回⼀个浮点数，表⽰能创造的最⼤魔法能量场强度（即两座塔与x轴构成的最⼤梯形⾯
积）
3. 编写单元测试来验证你的实现
4. 分析你的算法的时间复杂度和空间复杂度

解答：
我的思路：类似leetcode11盛最多水，但是不同的是由于求梯形面积，不能同理使用双指针，所以不能让双指针去一起移动。
我二分成两种方案：先移动左/右指针。
具体：左右指针分别位于最左最右端。
一、固定左指针，只移动右指针，找能形成最大面积的右指针。 之后将这个指针固定，再去移动左指针，找能形成最大面积的左指针。
二、（相反，上次我们先固定左）固定右指针，进行相反的操作。
将两次的最大面积相互比较得出最大面积。
代码：
using System;

public class EnergyFieldSystem
{
    public static float MaxEnergyField(int[] heights)
    {
        if (heights == null || heights.Length < 2)
        {
            return 0.0f;
        }

        int n = heights.Length;
        float maxEnergy = 0.0f;
        int left = 0;
        int right = n - 1;     
        float originS = (heights[left] + heights[right]) * (right - left);
        maxEnergy=Math.Max(maxEnergy, originS);
        //固定左边
        for (int i = right; i > left; i--)
        {
            float currS = (heights[left] + heights[i]) * (i - left);
            if (currS >= originS)
            { 
                right = i;
                originS = currS;
            }
        }
        //找左边
        for (int i = left; i < right; i++)
        {
            float currS = (heights[right] + heights[i]) * (right - i);
            if (currS >= originS)
            {
                left = i;
                originS = currS;
            }
        }
        maxEnergy = Math.Max(maxEnergy, originS);
        //刷新数据，固定右边
        left = 0;
        right = n - 1;
        originS = (heights[left] + heights[right]) * (right - left);
        for (int i = left; i <right; i++)
        {
            float currS = (heights[right] + heights[i]) * (right - i);
            if (currS >= originS)
            {
                left = i;
                originS = currS;
            }
        }
        //找右边
        for (int i = right; i >left; i--)
        {
            float currS = (heights[left] + heights[i]) * (i - left);
            if (currS >= originS)
            {
                right = i;
                originS = currS;
            }
        }
        maxEnergy = Math.Max(maxEnergy, originS);

        return maxEnergy/2.0f;
    }
    static void Main()
    {
        Console.WriteLine(MaxEnergyField(new int[] { 1, 8, 6, 2, 5, 4, 8, 3, 7 }));
    }
}
*时间复杂度O（n）
*空间复杂度O（1）常数级
#测试代码：
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Tests
{
    [TestClass()]
    
    public class EnergyFieldSystemTests
    {
        [TestMethod]
        public void TestMaxEnergyField()
        {
            Assert.AreEqual(52.5, EnergyFieldSystem.MaxEnergyField(new int[] { 1, 8, 6, 2, 5, 4, 8, 3, 7 }));
        }
        [TestMethod]
        public void TestMaxEnergyField_WithNullInput_ReturnsZero()
        {
            Assert.AreEqual(0, EnergyFieldSystem.MaxEnergyField(null));
        }

        [TestMethod]
        public void TestMaxEnergyField_WithEmptyArray_ReturnsZero()
        {
            Assert.AreEqual(0, EnergyFieldSystem.MaxEnergyField(new int[] { }));
        }

        [TestMethod]
        public void TestMaxEnergyField_WithSingleElement_ReturnsZero()
        {
            Assert.AreEqual(0, EnergyFieldSystem.MaxEnergyField(new int[] { 10 }));
        }

        [TestMethod]
        public void TestMaxEnergyField_WithTwoElements_ReturnsCorrectResult()
        {
            Assert.AreEqual(5, EnergyFieldSystem.MaxEnergyField(new int[] { 3, 7 }));
        }

        [TestMethod]
        public void TestMaxEnergyField_WithAllElementsSameHeight_ReturnsCorrectResult()
        {
            Assert.AreEqual(20, EnergyFieldSystem.MaxEnergyField(new int[] { 5, 5, 5, 5, 5 }));
        }

        [TestMethod]
        public void TestMaxEnergyField_WithLargeArray_ReturnsCorrectResult()
        {
            Assert.AreEqual(10004*3/2.0f, EnergyFieldSystem.MaxEnergyField(new int[] { 3 ,4 ,10000,1, 100, 4 }));
        }
    }
}
*测试全部通过，未发现反例。

进阶挑战（可选）
1. 如果我们允许玩家使⽤魔法道具来临时增加某个位置的塔的⾼度，你会如何修改你的算法？
在我的代码中，在求面积的时候只需要 (heights[left] + heights[i]+Item) * (right - left)/2;面积公式中上下底的和再加上道具的高度；如果有多个道具就加上总和，因为实际道具用在左右两边的哪个塔能量场强度不会改变
2. 在游戏的⾼级模式中，某些位置可能有建筑限制（⾼度为0）。你的算法如何处理这种情况？
可以将建筑限制的数据存在哈希表中，如HashSet<T>；在指针移动的时候只需查询表中是否有限制，如果有就继续移动即可。

创意思考
这个能量场机制如何影响玩家在游戏中的策略选择？你能想到如何将这个概念扩展到⼀个有趣的游戏
玩法中吗
我的思考：
策略性建筑布局
优化覆盖范围：玩家必须找到最佳位置来最大化能量场的覆盖范围，可能需要考虑地形高低、障碍物等因素。
协同效应：建造能量塔时，玩家需要考虑不同塔之间的能量场叠加，可能产生额外的效果或增强能量场。
游戏玩法扩展
能量场类型多样化：可以引入不同类型的能量塔，每种塔产生不同类型的能量场（例如攻击场、防御场、治疗场或者不同元素的魔法），玩家需要根据当前游戏情况选择合适的组合。
动态变化：能量场的强度可以随时间、天气或玩家行为而变化，增加游戏的动态性和不确定性。
具体游戏玩法设计
塔防与攻击结合：玩家不仅可以建造防御性的能量场来保护基地，还可以建造攻击性的能量场来攻击敌人。
能量场争夺战：在PvP模式中，玩家需要争夺地图上的关键位置来建立强大的能量场，控制这些位置可以获得资源或积分，或者试图摧毁别人占据重要地点的能量塔
任务与挑战：设计特定的任务，要求玩家在特定位置建立能量场来完成任务，例如保护某个NPC、激活某个机关等。
