4.魔法天赋评估系统背景
在我们的奇幻RPG⼿游"魔法师学院"中，玩家扮演⼀名新⼊学的魔法学徒。学院使⽤⼀种特殊的魔法
天赋评估系统来确定学徒的潜⼒。这个系统会测量学徒在两种不同魔法属性上的能⼒值。
任务
作为游戏开发团队的⼀员，你需要设计⼀个算法来处理魔法天赋评估的结果。系统会提供两组已排序
的能⼒值数据，你的任务是找出这两组数据合并后的中位数，作为学徒的综合天赋指数。
要求
1. 实现 FindMedianTalentIndex ⽅法，该⽅法接收两个参数：
◦ fireAbility :⼀个已排序（从⼩到⼤）的整数数组，表⽰⽕系魔法能⼒值
◦ iceAbility :⼀个已排序（从⼩到⼤）的整数数组，表⽰冰系魔法能⼒值
2. ⽅法应返回⼀个浮点数，表⽰两组能⼒值合并后的中位数（即综合天赋指数）
3. 编写单元测试来验证你的实现
4. 分析你的算法的时间复杂度和空间复杂度
5. 你的算法应该尽可能⾼效，⽬标是达到尽可能⾼的时间复杂度

代码：
using System;

public class TalentAssessmentSystem
{
    public static double FindMedianTalentIndex(int[] fireAbility, int[] iceAbility)
    {
        int totalLength = fireAbility.Length + iceAbility.Length;
        int[] merged = new int[totalLength];
        int i = 0, j = 0, k = 0;

        while (i < fireAbility.Length && j < iceAbility.Length)
        {
            if (fireAbility[i] < iceAbility[j])
            {
                merged[k++] = fireAbility[i++];
            }
            else
            {
                merged[k++] = iceAbility[j++];
            }
        }

        while (i < fireAbility.Length)
        {
            merged[k++] = fireAbility[i++];
        }

        while (j < iceAbility.Length)
        {
            merged[k++] = iceAbility[j++];
        }

        if (totalLength % 2 == 0)
        {
            return (merged[totalLength / 2 - 1] + merged[totalLength / 2]) / 2.0;
        }
        else
        {
            return merged[totalLength / 2];
        }
    }
    static void Main()
    { }
}
时间复杂度：O(m + n)，其中m是fireAbility数组的长度，n是iceAbility数组的长度。这是因为我们只需要遍历两个数组各一次。
空间复杂度：O(m + n)，因为我们创建了一个新的数组来存储合并后的结果。

单元测试：
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Tests
{
    [TestClass()]
    public class TalentAssessmentSystemTests
    {
        [TestMethod()]
        public void TestFindMedianTalentIndex()
        {
            Assert.AreEqual(8, TalentAssessmentSystem.FindMedianTalentIndex(new int[] { 1, 3, 7, 9, 11 }, new int[] { 2, 4, 8, 10, 12, 14 }));
        }
         [TestMethod()]
    public void TestFindMedianTalentIndex_BothArraysNotEmpty()
    {
        int[] fireAbility = {1, 3, 7, 9, 11};
        int[] iceAbility = {2, 4, 8, 10, 12, 14};
        double median = TalentAssessmentSystem.FindMedianTalentIndex(fireAbility, iceAbility);
        Assert.AreEqual(8, median);
    }

    [TestMethod()]
    public void TestFindMedianTalentIndex_OneArrayEmpty()
    {
        int[] fireAbility = {};
        int[] iceAbility = {2, 4, 8, 10, 12, 14};
        double median = TalentAssessmentSystem.FindMedianTalentIndex(fireAbility, iceAbility);
        Assert.AreEqual(9, median);
    }

    [TestMethod()]
    public void TestFindMedianTalentIndex_OddTotalLength()
    {
        int[] fireAbility = {1, 3, 7};
        int[] iceAbility = {2, 4, 8, 10, 12};
        double median = TalentAssessmentSystem.FindMedianTalentIndex(fireAbility, iceAbility);
        Assert.AreEqual(5.5, median);
    }

    [TestMethod()]
    public void TestFindMedianTalentIndex_EvenTotalLength()
    {
        int[] fireAbility = {1, 3, 7, 9};
        int[] iceAbility = {2, 4, 8, 10, 12};
        double median = TalentAssessmentSystem.FindMedianTalentIndex(fireAbility, iceAbility);
        Assert.AreEqual(7, median);
    }

    [TestMethod()]
    public void TestFindMedianTalentIndex_ElementsOverlap()
    {
        int[] fireAbility = {1, 3, 7, 9, 11};
        int[] iceAbility = {7, 9, 11, 12, 14};
        double median = TalentAssessmentSystem.FindMedianTalentIndex(fireAbility, iceAbility);
        Assert.AreEqual(9, median);
    }

    [TestMethod()]
    public void TestFindMedianTalentIndex_SameElements()
    {
        int[] fireAbility = {1, 2, 3};
        int[] iceAbility = {1, 2, 3};
        double median = TalentAssessmentSystem.FindMedianTalentIndex(fireAbility, iceAbility);
        Assert.AreEqual(2, median);
    }
    }
}
进阶挑战（可选）
1. 如果我们需要实时更新⼤量学徒的天赋指数，你会如何优化你的算法或数据结构？
2. 在游戏的⾼级模式中，可能会有更多的魔法属性（不仅仅是⽕和冰）。你的算法如何扩展到处理k
个有序数组的中位数？

使用堆（Heap）数据结构：
使用两个堆（一个大顶堆和一个小顶堆）来维护中位数。大顶堆存储较小的一半元素，小顶堆存储较大的一半元素。
当新数据到来时，我们可以根据其值将其插入到相应的堆中，并调整两个堆以保持平衡。
中位数可以通过查看两个堆的堆顶元素来快速获取。
多路归并：
将 k 个数组的元素合并到一个有序数组中，然后找到中位数。
可以使用类似于归并排序的多路归并算法来实现这一点。
