3.魔法宝箱探险背景
在我们即将推出的奇幻冒险⼿游“魔法宝藏”中，玩家将探索⼀个充满神秘宝箱的古代遗迹。这些宝
箱排列在⼀条直线上，每个宝箱⾥都藏有不同价值的魔法宝物。
任务
你需要设计⼀个算法来帮助玩家在游戏中做出最优选择。然⽽，这些宝箱被施加了⼀个奇特的魔法诅
咒：如果打开了相邻的两个宝箱，就会触发陷阱，导致玩家损失所有已收集的宝物！
要求
1. 实现 MaxTreasureValue ⽅法，该⽅法接收⼀个参数：
◦ treasures :⼀个整数数组，表⽰每个宝箱中宝物的价值
2. ⽅法应返回⼀个整数，表⽰在不触发陷阱的情况下，玩家能够获得的最⼤宝物总价值
3. 编写单元测试来验证你的实现
4. 分析你的算法的时间复杂度和空间复杂度

解答：
使用动态规划：定义 dp[i] 为到达第 i 个宝箱时，玩家能够获得的最大宝物总价值。

对于每个宝箱 i（从第三个宝箱开始，即索引为 2），玩家有两个选择：
打开当前宝箱，然后跳过下一个宝箱（因为不能打开相邻的宝箱），所以总价值将是 dp[i-2] + treasures[i]。
不打开当前宝箱，直接考虑下一个宝箱，总价值将是 dp[i-1]。
因此，状态转移方程为：
dp[i] = Math.Max(dp[i-1], dp[i-2] + treasures[i])

dp数组初始化
dp[0]：只有一个宝箱时，最大价值就是该宝箱的价值，即 dp[0] = treasures[0]。
dp[1]：有两个宝箱时，最大价值是两个宝箱中价值较大的那个，即 dp[1] = Math.Max(treasures[0], treasures[1])。

注：这里进行了优化，将dp一维压缩为两个变量， pre，aft代表dp[i-2],dp[i-1]
代码：
using System;
public class TreasureHuntSystem
{
    public static int MaxTreasureValue(int[] treasures)
{
    if (treasures == null || treasures.Length == 0)
        return 0;
    if (treasures.Length == 1)
        return treasures[0];
    if (treasures.Length == 2)
        return Math.Max(treasures[0], treasures[1]);

    //int[] dp = new int[treasures.Length];
    int pre= treasures[0];
    int aft = Math.Max(treasures[0], treasures[1]);

    for (int i = 2; i < treasures.Length; i++)
    {
        int t = Math.Max(aft, pre + treasures[i]);
        pre = aft;
        aft = t;
    }

    return aft;
}
    static void Main()
    {
        Console.WriteLine(MaxTreasureValue(new int[] { 4, 3, 2, 3 }));
    }
}

*时间复杂度：算法的时间复杂度是 O(n)
*空间复杂度：由于进行了优化空间复杂度是O（1）常数级

进阶挑战（可选）
1. 如果我们允许玩家使⽤⼀次"魔法钥匙"，可以安全地打开任意两个相邻的宝箱⽽不触发陷阱，你会
如何修改你的算法？

2. 在游戏的⾼级关卡中，有些宝箱可能包含负值（表⽰陷阱会扣除玩家的分数）。你的算法如何处理
这种情况？

解答：
状态定义
我们定义 dp[i][0] 为到达第 i 个宝箱时，玩家不使用魔法钥匙能够获得的最大宝物总价值。dp[i][1] 为到达第 i 个宝箱时，玩家已经使用过魔法钥匙能够获得的最大宝物总价值。

状态转移方程
对于每个宝箱 i（从第三个宝箱开始，即索引为 2），我们有以下几种情况：

不使用魔法钥匙，不打开当前宝箱：dp[i][0] = dp[i-1][0]
不使用魔法钥匙，打开当前宝箱：dp[i][0] = Math.Max(dp[i][0], dp[i-2][0] + treasures[i])
使用魔法钥匙，打开当前宝箱和前一个宝箱：dp[i][1] = Math.Max(dp[i-1][1], dp[i-2][0] + treasures[i-1] + treasures[i]) （注意这里 dp[i-2][0] 是因为在使用魔法钥匙之前，我们不能打开第 i-1 个宝箱）
因此，状态转移方程为：

dp[i][0] = Math.Max(dp[i-1][0], dp[i-2][0] + treasures[i])
dp[i][1] = Math.Max(dp[i-1][1], dp[i-2][0] + treasures[i-1] + treasures[i])

初始化
dp[0][0] = treasures[0]
dp[0][1] = treasures[0] （即使使用了魔法钥匙，但在第一个宝箱时没有效果）
dp[1][0] = Math.Max(Math.Max(treasures[0], treasures[1]),0);//选一个或者都不选
dp[1][1] = Math.Max(treasures[0] + treasures[1], dp[1][0]);//选一个或者都不选或者都选

进阶的代码：
using System;

public class TreasureHuntSystem
{
    public static int MaxTreasureValue(int[] treasures)
    {
        if (treasures == null || treasures.Length == 0)
            return 0;

        int n = treasures.Length;
        if (n == 1)
            return treasures[0];

        // dp[i, 0] 表示不使用魔法钥匙到达第i个宝箱的最大价值
        // dp[i, 1] 表示使用魔法钥匙到达第i个宝箱的最大价值
        int[,] dp = new int[n, 2];

        // 初始化
        dp[0, 0] = Math.Max(treasures[0],0);
        dp[0, 1] = Math.Max(treasures[0],0);
        dp[1, 0] = Math.Max(Math.Max(treasures[0], treasures[1]),0);//选一个或者都不选
        dp[1, 1] = Math.Max(treasures[0] + treasures[1], dp[1,0]);

        // 动态规划填表
        for (int i = 2; i < n; i++)
        {
            dp[i, 0] = Math.Max(dp[i - 1, 0], dp[i - 2, 0] + treasures[i]);
            dp[i, 1] = Math.Max(dp[i - 1, 1], dp[i - 2, 0] + treasures[i - 1] + treasures[i]);
        }

        // 返回最大值
        return Math.Max(dp[n - 1, 0], dp[n - 1, 1]);
    }
    static void Main()
    {
        // 测试使用魔法钥匙的情况
        Console.WriteLine(MaxTreasureValue(new int[] { 2, 7, 9, 3, 1 })); 
        // 测试包含负值宝箱的情况
        Console.WriteLine(MaxTreasureValue(new int[] { 3, -1, -1, -2, 4 })); 
    }
}
进阶的测试代码：
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Tests
{
    [TestClass()]
    public class TreasureHuntSystemTests
    {
        [TestMethod()]
        public void MaxTreasureValueTest()
        {
            // 测试空数组
            Assert.AreEqual(0, TreasureHuntSystem.MaxTreasureValue(null));
            // 测试只有一个宝箱的情况
            Assert.AreEqual(3, TreasureHuntSystem.MaxTreasureValue(new int[] { 3 }));
            // 测试示例
            Assert.AreEqual(14, TreasureHuntSystem.MaxTreasureValue(new int[] { 3, 1, 5, 2, 4 }));
            // 测试两个宝箱的情况
            Assert.AreEqual(8, TreasureHuntSystem.MaxTreasureValue(new int[] { 3, 5 }));
            // 测试更多宝箱的情况
            Assert.AreEqual(19, TreasureHuntSystem.MaxTreasureValue(new int[] { 2, 7, 9, 3, 1 }));
            Assert.AreEqual(12, TreasureHuntSystem.MaxTreasureValue(new int[] { 3, -1, 5, -2, 4 }));
            Assert.AreEqual(7, TreasureHuntSystem.MaxTreasureValue(new int[] { 3, -1, -1, -2, 4 }));
            Assert.AreEqual(0, TreasureHuntSystem.MaxTreasureValue(new int[] { -1, -2, -3 }));
        }
    }
}


