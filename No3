3.魔法宝箱探险背景
在我们即将推出的奇幻冒险⼿游“魔法宝藏”中，玩家将探索⼀个充满神秘宝箱的古代遗迹。这些宝
箱排列在⼀条直线上，每个宝箱⾥都藏有不同价值的魔法宝物。
任务
你需要设计⼀个算法来帮助玩家在游戏中做出最优选择。然⽽，这些宝箱被施加了⼀个奇特的魔法诅
咒：如果打开了相邻的两个宝箱，就会触发陷阱，导致玩家损失所有已收集的宝物！
要求
1. 实现 MaxTreasureValue ⽅法，该⽅法接收⼀个参数：
◦ treasures :⼀个整数数组，表⽰每个宝箱中宝物的价值
2. ⽅法应返回⼀个整数，表⽰在不触发陷阱的情况下，玩家能够获得的最⼤宝物总价值
3. 编写单元测试来验证你的实现
4. 分析你的算法的时间复杂度和空间复杂度

解答：
使用动态规划：定义 dp[i] 为到达第 i 个宝箱时，玩家能够获得的最大宝物总价值。

对于每个宝箱 i（从第三个宝箱开始，即索引为 2），玩家有两个选择：
打开当前宝箱，然后跳过下一个宝箱（因为不能打开相邻的宝箱），所以总价值将是 dp[i-2] + treasures[i]。
不打开当前宝箱，直接考虑下一个宝箱，总价值将是 dp[i-1]。
因此，状态转移方程为：
dp[i] = Math.Max(dp[i-1], dp[i-2] + treasures[i])

dp数组初始化
dp[0]：只有一个宝箱时，最大价值就是该宝箱的价值，即 dp[0] = treasures[0]。
dp[1]：有两个宝箱时，最大价值是两个宝箱中价值较大的那个，即 dp[1] = Math.Max(treasures[0], treasures[1])。

注：这里进行了优化，将dp一维压缩为两个变量， pre，aft代表dp[i-2],dp[i-1]
代码：
using System;
public class TreasureHuntSystem
{
    public static int MaxTreasureValue(int[] treasures)
{
    if (treasures == null || treasures.Length == 0)
        return 0;
    if (treasures.Length == 1)
        return treasures[0];
    if (treasures.Length == 2)
        return Math.Max(treasures[0], treasures[1]);

    //int[] dp = new int[treasures.Length];
    int pre= treasures[0];
    int aft = Math.Max(treasures[0], treasures[1]);

    for (int i = 2; i < treasures.Length; i++)
    {
        int t = Math.Max(aft, pre + treasures[i]);
        pre = aft;
        aft = t;
    }

    return aft;
}
    static void Main()
    {
        Console.WriteLine(MaxTreasureValue(new int[] { 4, 3, 2, 3 }));
    }
}

*时间复杂度：算法的时间复杂度是 O(n)
*空间复杂度：由于进行了优化空间复杂度是O（1）常数级

进阶挑战（可选）
1. 如果我们允许玩家使⽤⼀次"魔法钥匙"，可以安全地打开任意两个相邻的宝箱⽽不触发陷阱，你会
如何修改你的算法？
2. 在游戏的⾼级关卡中，有些宝箱可能包含负值（表⽰陷阱会扣除玩家的分数）。你的算法如何处理
这种情况？
创意思考（可选）
这个机制可能会在游戏中带来哪些有趣的策略选择？你能想到如何将这个概念扩展到⼀个完整的游戏
关卡设计中吗？
